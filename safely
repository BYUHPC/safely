#!/bin/bash



version=0.1.0



# Usage
usage="usage: $0 [-h] [-v] [-w dir ...] [--] command [args ...]

$0 runs an arbitrary command while restricting write access to explicitly specified directories. It can allow you to run potentially risky commands in a controlled setting.

Any directory specified with \`-w\` or \`--writable\` can be written in, including subdirectories, but no directories outside of those specified can be modified by the command.

As an example, '$0 --writable /tmp rm -rf $HOME/*' will fail to destroy your home directory, but '$0 --writable $HOME rm -rf $HOME/*' will succeed.

Options:
    -h|--help
        Print this help message

    -v|--version
        Print the version number

    -w|--writable dir
        Make 'dir' writable by the command"



# Error and warning helpers
error_exit() {
    local retcode="$1"
    local message="$2"
    echo "ERROR: $message" >&2
    echo ======
    echo "$usage" >&2
    echo ======
    echo "ERROR: $message" >&2
    exit "$retcode"
}

warn() {
    echo "WARNING: $@" >&2
}



# Parse
unset binds
unsafe=false
while [ $# -gt 0 ]; do
    case "$1" in
        -h|--help)
            echo "$usage"
            exit
            ;;
        -v|--version)
            echo "$0 version $version"
            exit
            ;;
        -w|--writable)
            [[ -n "$2" ]] || error_exit 2 "argument for $1 is missing"
            binds="${binds}$(realpath -e "$2")," || error_exit 1 "$2 is not a valid path"
            [[ "$2" = / ]] && unsafe=true
            shift 2
            ;;
        --)
            shift
            break
            ;;
        -*)
            error_exit 2 "unrecognized flag $1"
            ;;
        *)
            break
            ;;
    esac
done
[[ $# -gt 0 ]] || error_exit 2 "command is missing"



# If `/` was given as a writable directory, we can just run the command and exit
if [[ "$unsafe" = true ]]; then
    warn "running without protection since / is writable"
    "$@"
    exit
fi



# Create the pseudo-container
container="$(mktemp -d -t safely-container-XXXXXX)"
mkdir "$container"/{dev,sys,proc}

trap 'rm -rf "$container"' EXIT

# Create symlinks and find read-only binds from mounts and /*
while read f; do
    ls "$f" &>/dev/null || continue # no need to mount anything we can't see
    if [[ -L "$f" ]]; then
        ln -s "$(realpath "$f")" "${container}${f}"
    elif [[ "$f" == *,* ]]; then
        warn "not mounting directory containing ',': $f"
    else
        [[ "$binds" == *",$f,"* || "$binds" == "$f,"* ]] || binds="$f:$f:ro,$binds"
    fi
done < <((df -a --output=target | sed 1d; ls -d /*) | sort -r | uniq | head -n -1)



# Run
work_dir="$PWD"
cd / # Can't to be in $HOME or --no-home won't work
apptainer --silent exec --no-home --env PATH="$PATH" --pwd "$work_dir" --bind "$binds" "$container" "$@"
